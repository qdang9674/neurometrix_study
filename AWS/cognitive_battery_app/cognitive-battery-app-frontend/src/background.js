require('dotenv').config();
const { ipcMain } = require('electron');
const path = require('path');
const os = require('os');
const { spawn, exec } = require('child_process');
const net = require('net');
const isDevelopment = process.env.NODE_ENV !== 'production';
const awsIot = require('aws-iot-device-sdk');
const fs = require('fs');
const {SerialPort} = require('serialport')
import { app, protocol, BrowserWindow, screen } from 'electron';
import { createProtocol } from 'vue-cli-plugin-electron-builder/lib';
import installExtension, { VUEJS3_DEVTOOLS } from 'electron-devtools-installer';

/*
  variables, exit codes, etc.
*/
let computer_name = null;
let device = null;
let subjectId = null;
let currentTask = null;
let currentEcgDevice = null;
let scriptPath;

if (isDevelopment) {
  scriptPath = path.join(__dirname, '..', 'public', 'scripts');
} else {
  scriptPath = path.join(process.resourcesPath, 'scripts');
}

const EYE_PIPE_NAME_PATH = '\\\\.\\pipe\\eye_pipe';
const SENSOR_PIPE_NAME_PATH = '\\\\.\\pipe\\sensor_pipe';

let sensorConnected = false;
let eyeConnected = false;

const EYE_EXIT_CODES = Object.freeze({
  0: "Eye tracker disconnected",
  1: "Eye tracker setup interrupted", //"Invalid eye tracker arguments",
  2: "Eye tracker not found",
  3: "Failed to open eye tracker pipe",
  4: "Connection to eye tracker pipe unexpectedly closed",
  5: "Eye tracker unexpectedly disconnected",
  99: "Unhandled eye tracker exception"
});

const ARDUINO_EXIT_CODES = Object.freeze({
  0: "ECG disconnected",
  1: "ECG setup interrupted", //"Invalid ECG arguments",
  2: "Could not open COM port",
  3: "Failed to open ECG pipe",
  4: "Connection to ECG pipe unexpectedly closed",
  5: "Failed to open ECG serial port",
  6: "Failed to find ECG device within acceptable timeout period",
  99: "Unhandled ECG exception"
}); 

const MOVESENSE_EXIT_CODES = Object.freeze({
    0: "ECG disconnected",
    1: "ECG setup interrupted", //"Invalid ECG arguments",
    2: "ECG sensor end with given serial not found",
    3: "Failed to open ECG pipe",
    4: "Connection to ECG pipe unexpectedly closed",
    5: "Failed to open ECG serial port",
    99: "Unhandled ECG exception"
});

// list of arduino vendorid-productid pairs. used for dynamically idenfiying arduino devices on com ports
const ARDUINO_VID_PID = [
  { vendorId: '03EB', productId: '2145' }, // ATMEGA328P-XMINI (CDC ACM)
  // we can add more if we have different arduinos
];




/*
  window setup generated by electron
*/
protocol.registerSchemesAsPrivileged([
  { scheme: 'app', privileges: { secure: true, standard: true } }
]);
async function createWindow() {
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width, height } = primaryDisplay.workAreaSize;

  const win = new BrowserWindow({
    autoHideMenuBar: true,
    width: width,
    height: height,
    webPreferences: {
      nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION,
      contextIsolation: !process.env.ELECTRON_NODE_INTEGRATION,
      preload: path.join(__dirname, 'preload.js')
    }
  });

  if (process.env.WEBPACK_DEV_SERVER_URL) {
    await win.loadURL(process.env.WEBPACK_DEV_SERVER_URL);
    if (!process.env.IS_TEST) win.webContents.openDevTools();
  } else {
    createProtocol('app');
    win.loadURL('app://./index.html');
  }
}
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    disconnectIot();
    localStorage.clear();
    app.quit();
  }
});
app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) createWindow();
});
app.on('ready', async () => {
  if (isDevelopment && !process.env.IS_TEST) {
    try {
      await installExtension(VUEJS3_DEVTOOLS);
    } catch (e) {
      console.error('Vue Devtools failed to install:', e.toString());
    }
  }
  await createWindow();
  // get computer name
  computer_name = getComputerName();
  // open pipes as soon as window is created
  setupPipeServer(EYE_PIPE_NAME_PATH, 'eye');
  setupPipeServer(SENSOR_PIPE_NAME_PATH, 'sensor');
});
if (isDevelopment) {
  if (process.platform === 'win32') {
    process.on('message', (data) => {
      if (data === 'graceful-exit') {
        localStorage.clear();
        app.quit();
      }
    });
  } else {
    process.on('SIGTERM', () => {
      localStorage.clear();
      app.quit();
    });
  }
}



/*
  IPC event listeners - handle commands from the renderer process
*/
ipcMain.on('toMain', (event, args) => {
  console.log('[IPC MAIN]', args);
  switch (args.command) {
    case 'sign-in':
      subjectId = args.subjectId;
      console.log('[IPC MAIN] sign-in api call for subjectId:', args.subjectId);
      break;

    case 'set-ecg-device':
      currentEcgDevice = args.device;
      break;

    case 'start-data-collection':
      console.log(`[IPC MAIN] starting data collection processes for subjectId "${args.subjectId}" using ${args.device} ecg device, performing task "${args.task}"...`);
      startDataCollection(args.device, event);
      break;

    case 'stop-data-collection':
      console.log('[IPC MAIN] stopping data collection...');
      stopDataCollection(event);
      break;

    case 'update-task':
      currentTask = args.task;
      break;

    case 'update-computer-name':
      // check if the provided computer name is empty or null, use desktop name if so
      computer_name = args.computer_name ? args.computer_name.trim() : os.hostname();
      
      if (!computer_name) {
          computer_name = os.hostname();
      }

      const filePath = path.join(__dirname, 'computer_name.txt');
      fs.writeFile(filePath, computer_name, (err) => {
          if (err) {
              console.error('Error writing to file:', err);
          } else {
              console.log(`Computer name updated successfully to: ${computer_name}`);
          }
      });
      break;
  

    case 'get-computer-name':
      event.reply('fromMain', { computer_name: computer_name });
      break;

    case 'setup-iot':
      console.log('[IPC MAIN] setting up IoT...');
      setupIot(event);
      break;

    case 'setup-eye-tracker':
      console.log('[IPC MAIN] setting up eye tracker...');
      setupEyeTracker(event);
      break;

    case 'setup-sensor':
      console.log('[IPC MAIN] setting up ECG sensor...');
      setupSensor(currentEcgDevice, event);
      break;

    case 'disconnect-iot':
      console.log('[IPC MAIN] disconnecting IoT...');
      disconnectIot(event);
      break;

    case 'send-iot-message':
      console.log('[IPC MAIN] sending IoT message...');
      sendIotMessage(args.topic, args.message, event);
      break;

    default:
      console.log('[IPC MAIN] no command given');
  }
});



/*
  eye tracker setup - creates a background process for the eye executable.
  the executable writes data to the eye pipe.
*/
function setupEyeTracker(event) {
  const recordEyePath = path.join(scriptPath, 'record_eye_for_exe.exe');
  const eyeProcess = spawn('cmd.exe', ['/C', recordEyePath, EYE_PIPE_NAME_PATH]);

  console.log('Connecting eye tracker...');
  event.reply('fromMain', { eyeStatus: 'Connecting eye tracker...' });

  eyeProcess.stdout.on('data', (data) => {
    console.log(`[RECORD_EYE] stdout: ${data}`);
    // event.reply('fromMain', { eyeStatus: `Record_eye output: ${data.toString()}` });
  });

  eyeProcess.stderr.on('data', (data) => {
    console.error(`[RECORD_EYE] stderr: ${data}`);
    // event.reply('fromMain', { eyeError: `Record_eye error: ${data.toString()}` });
  });

  eyeProcess.on('close', (code) => {
    console.log(`[RECORD_EYE] ${EYE_EXIT_CODES[code]}`);
    eyeConnected = false;
    event.reply('fromMain', { eyeStatus: `${EYE_EXIT_CODES[code]}` });
  });

  return eyeProcess;
}



/*
  sensor setup - creates a background process for either the arduino or movesense executable.
  the executable writes data to the sensor pipe. 
  arduino COM port is dynamically identified by looking up vendorID-productID pairs defined in the variables above.
  *** the movesense serial number is currently hardcoded. ***
*/
async function setupSensor(ecgDevice, event) {
  let filename;
  let sensorArgs;
  let sensorExitCodes;

  console.log(`Setting up sensor for device type: ${ecgDevice}`);

  switch (ecgDevice) {
    case 'arduino':
      filename = 'record_arduino_sensor_for_exe.exe';
      sensorExitCodes = ARDUINO_EXIT_CODES;

      try {
        const ports = await SerialPort.list();
        console.log('Available serial ports:', ports);

        const arduinoPorts = ports.filter((port) => {
          return ARDUINO_VID_PID.some(
            (vidpid) =>
              port.vendorId &&
              port.productId &&
              port.vendorId.toLowerCase() === vidpid.vendorId.toLowerCase() &&
              port.productId.toLowerCase() === vidpid.productId.toLowerCase()
          );
        });

        console.log('Detected Arduino ports:', arduinoPorts);

        if (arduinoPorts.length === 1) {
          const COM_PORT = arduinoPorts[0].path;
          sensorArgs = COM_PORT;

          const recordSensorPath = path.join(scriptPath, filename);
          const sensorProcess = spawn('cmd.exe', ['/C', recordSensorPath, sensorArgs, SENSOR_PIPE_NAME_PATH]);

          console.log(`Connecting ECG sensor on port ${COM_PORT}`);
          event.reply('fromMain', { sensorStatus: 'Connecting ECG sensor...' });

          sensorProcess.stdout.on('data', (data) => {
            console.log(`[RECORD_SENSOR] stdout: ${data}`);
          });

          sensorProcess.stderr.on('data', (data) => {
            console.error(`[RECORD_SENSOR] stderr: ${data}`);
          });

          sensorProcess.on('close', (code) => {
            console.log(`[RECORD_SENSOR] Closed with code ${code}: ${sensorExitCodes[code] || 'Unknown code'}`);
            sensorConnected = false;
            event.reply('fromMain', { sensorStatus: `${sensorExitCodes[code] || 'Unknown error'}` });
          });

          return sensorProcess;
        } else if (arduinoPorts.length > 1) {
          console.error('[IPC MAIN] Multiple Arduinos found. Please disconnect all but one.');
          event.reply('fromMain', { sensorError: 'Multiple Arduinos found. Please disconnect all but one.' });
          return null;
        } else {
          console.error('[IPC MAIN] Arduino not found');
          event.reply('fromMain', { sensorError: 'Arduino not found' });
          return null;
        }
      } catch (err) {
        console.error('[IPC MAIN] Error listing serial ports:', err);
        event.reply('fromMain', { sensorError: 'Error listing serial ports' });
        return null;
      }

    case 'movesense':
      filename = 'record_movesense_sensor_for_exe.exe';
      sensorExitCodes = MOVESENSE_EXIT_CODES;

      try {
        const END_OF_SERIAL = '234530000211'; // hardcoded
        sensorArgs = END_OF_SERIAL;

        const recordSensorPath = path.join(scriptPath, filename);
        const sensorProcess = spawn('cmd.exe', ['/C', recordSensorPath, sensorArgs, SENSOR_PIPE_NAME_PATH]);

        console.log('Connecting ECG sensor...');
        event.reply('fromMain', { sensorStatus: 'Connecting ECG sensor...' });

        sensorProcess.stdout.on('data', (data) => {
          console.log(`[RECORD_SENSOR] stdout: ${data}`);
          // event.reply('fromMain', { sensorStatus: `Record_sensor output: ${data.toString()}` });
        });

        sensorProcess.stderr.on('data', (data) => {
          console.error(`[RECORD_SENSOR] stderr: ${data}`);
          // event.reply('fromMain', { sensorError: `Record_sensor error: ${data.toString()}` });
        });

        sensorProcess.on('close', (code) => {
          console.log(`${sensorExitCodes[code]}`);
          sensorConnected = false;
          event.reply('fromMain', { sensorStatus: `${sensorExitCodes[code]}` });
        });

        return sensorProcess;
      } catch (err) {
        console.error('[IPC MAIN] Error setting up Movesense sensor:', err);
        event.reply('fromMain', { sensorError: 'Error setting up Movesense sensor' });
        return null;
      }

    default:
      console.error('[IPC MAIN] Invalid device type');
      event.reply('fromMain', { sensorError: 'Invalid device type' });
      return null;
  }
}



/*
  start data collection - calls the appropriate functions for spawning background processes for eye or ecg.
  creates a listener to kill background processes.
*/
function startDataCollection(device, event) {
  let eyeProcess;
  if (!eyeConnected){
    eyeProcess = setupEyeTracker(event);
  }

  let sensorProcess;
  if (!sensorConnected){
    sensorProcess = setupSensor(device, event);
  }

  if ((!sensorConnected && !sensorProcess) || (!eyeConnected && !eyeProcess)) {
    return;
  }

  ipcMain.once('stop-data-collection', () => {
    if (eyeProcess) eyeProcess.kill();
    if (sensorProcess) sensorProcess.kill();
    stopDataCollection();
    event.reply('fromMain', { sensorStatus: 'ECG disconnected', eyeStatus: 'Eye tracker disconnected' });
  });
}



/*
  stop data collection - force kill background processes
*/
function stopDataCollection(event) {
  exec('taskkill /f /im record_eye_for_exe.exe');
  exec('taskkill /f /im record_arduino_sensor_for_exe.exe');
  exec('taskkill /f /im record_movesense_sensor_for_exe.exe');
  if (event) {
    event.reply('fromMain', { sensorStatus: 'ECG disconnected', eyeStatus: 'Eye tracker disconnected' });
  }
}



/*
  setup pipe server - opens the named windows pipes for the executables to write data into.
  data is read from the pipes, accumulated into 1 second batches, and published to the appropriate IoT topics.
*/
function setupPipeServer(pipeName, type) {
  const server = net.createServer((stream) => {
    let dataBuffer = [];

    const dirPath = path.join(__dirname, 'cached_data', type);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }

    let filePath = path.join(dirPath, `${type}_data_${Date.now()}.json`);
    let writeStream = fs.createWriteStream(filePath, { flags: 'a' });

    writeStream.write('[\n');
    let isFirstBatch = true;

    let timer = setInterval(() => {
      if (dataBuffer.length > 0) {
        let dataToSend = dataBuffer.slice();
        dataBuffer = [];

        let dataByTopic = {};
        dataToSend.forEach(({ topic, data }) => {
          if (!dataByTopic[topic]) {
            dataByTopic[topic] = [];
          }
          dataByTopic[topic].push(data);
        });

        for (let topic in dataByTopic) {
          let entries = dataByTopic[topic].length;
          console.log(`[DATA SEND] Sent ${entries} entries to topic ${topic}`);
          sendIotMessage(topic, dataByTopic[topic]);

          if (!isFirstBatch) {
            writeStream.write(',\n');
          } else {
            isFirstBatch = false;
          }
          writeStream.write(JSON.stringify({ topic, data: dataByTopic[topic] }, null, 2));
        }
      }
    }, 1000); // 1 second

    stream.on('data', (data) => {
      // update device status on first data reception
      if (type === 'sensor' && !sensorConnected) {
        sensorConnected = true;
        BrowserWindow.getAllWindows().forEach(win => {
          win.webContents.send('fromMain', { sensorStatus: 'ECG connected' });
        });
      }
      if (type === 'eye' && !eyeConnected) {
        eyeConnected = true;
        BrowserWindow.getAllWindows().forEach(win => {
          win.webContents.send('fromMain', { eyeStatus: 'Eye tracker connected' });
        });
      }

      const decoder = new TextDecoder('utf-8');
      let jsonString = decoder.decode(data);
      jsonString = jsonString.replace(/NaN/g, 0); // replace NaN with 0
      let objects = jsonString.split(/(?<=})\s*(?={)/); // split into individual JSON objects

      objects.forEach(objString => {
        let validJsonString = objString.replace(/'/g, '"'); // replace single quotes with double quotes
        let jsonData;
        try {
          jsonData = JSON.parse(validJsonString);
        } catch (err) {
          console.error(`[${type.toUpperCase()} PIPE] JSON parse error:`, err);
          return; // skip malformed JSON
        }

        let transformedData;
        let topic;

        if (type === 'eye') {
          transformedData = {
            timestamp: jsonData.Timestamp || 'null timestamp',
            computer_name: computer_name,
            user_id: subjectId || 'null subjectId',
            game_type: currentTask || 'null task',
            eye_data: {
              gaze_x: jsonData.Gaze_X || 0,
              gaze_y: jsonData.Gaze_Y || 0,
              pupil_left: jsonData.Pupil_left || 0,
              pupil_right: jsonData.Pupil_right || 0
            }
          };
          topic = 'sensor/eye';
        } else if (type === 'sensor') {
          if (currentEcgDevice === 'movesense') {
            if (jsonData.data_type === 'Heart_Data') {
              transformedData = {
                timestamp: jsonData.Timestamp || 'null timestamp',
                computer_name: computer_name,
                user_id: subjectId || 'null subjectId',
                game_type: currentTask || 'null task',
                ecg_data: jsonData.ecg_data || 0,
              };
              topic = 'sensor/ecg';
            } else if (jsonData.data_type === 'IMU9') {
              transformedData = {
                timestamp: jsonData.Timestamp || 'null timestamp',
                computer_name: computer_name,
                user_id: subjectId || 'null subjectId',
                game_type: currentTask || 'null task',
                acc_x: jsonData.acc_x || 0,
                acc_y: jsonData.acc_y || 0,
                acc_z: jsonData.acc_z || 0,
                gyro_x: jsonData.gyro_x || 0,
                gyro_y: jsonData.gyro_y || 0,
                gyro_z: jsonData.gyro_z || 0,
                magn_x: jsonData.magn_x || 0,
                magn_y: jsonData.magn_y || 0,
                magn_z: jsonData.magn_z || 0
              };
              topic = 'sensor/imu9';
            }
          } else {
            // arduino ECG
            transformedData = {
              timestamp: jsonData.Timestamp || 'null timestamp',
              computer_name: computer_name,
              user_id: subjectId || 'null subjectId',
              game_type: currentTask || 'null task',
              ecg_data: jsonData.ecg_data || 0,
            };
            topic = 'sensor/ecg';

            // get Arduino SNR from ecg_data and pass to renderer
            let snr = jsonData.snr_values;
            BrowserWindow.getAllWindows().forEach(win => {
              win.webContents.send('fromMain', { signalStrength: snr });
            });
          }
        }

        if (transformedData) {
          dataBuffer.push({ topic, data: transformedData });
          // removed individual write to file to batch write later
        }
      });
    });

    stream.on('end', () => {
      clearInterval(timer);
      // close the JSON array in the file
      writeStream.write('\n]');
      writeStream.end();
      if (type === 'sensor') {
        sensorConnected = false;
        BrowserWindow.getAllWindows().forEach(win => {
          win.webContents.send('fromMain', { sensorStatus: 'ECG disconnected' });
        });
      }
      if (type === 'eye') {
        eyeConnected = false;
        BrowserWindow.getAllWindows().forEach(win => {
          win.webContents.send('fromMain', { eyeStatus: 'Eye tracker disconnected' });
        });
      }
      console.log(`[${type.toUpperCase()} PIPE] End of data`);
    });

    stream.on('error', (err) => {
      console.error(`[${type.toUpperCase()} PIPE] Stream error:`, err);
      clearInterval(timer);
      // close the JSON array in the file
      writeStream.write('\n]');
      writeStream.end();
      BrowserWindow.getAllWindows().forEach(win => {
        win.webContents.send('fromMain', { [`${type}PipeError`]: err.message });
      });
    });
  });

  server.listen(pipeName, () => {
    console.log(`[IPC MAIN] ${type} pipe server listening on ${pipeName}`);
  });

  server.on('error', (err) => {
    console.error(`[IPC MAIN] ${type} pipe server error:`, err);
    BrowserWindow.getAllWindows().forEach(win => {
      win.webContents.send('fromMain', { [`${type}PipeError`]: err.message });
    });
  });
}



/*
  setup IoT - creates the IoT client for publishing messages to.
*/
function setupIot(event) {
  device = awsIot.device({
    keyPath: process.env.AWS_IOT_KEY_PATH,
    certPath: process.env.AWS_IOT_CERT_PATH,
    caPath: process.env.AWS_IOT_CA_PATH,
    clientId: process.env.AWS_IOT_CLIENT_ID,
    host: process.env.AWS_IOT_HOST,
    debug: true
  });

  device.on('connect', function() {
    console.log('[IOT] Connected to AWS IoT');
    event.reply('fromMain', { iotStatus: 'Online' });
  });

  device.on('message', function(topic, payload) {
    console.log('[IOT] Message received:', topic, payload.toString());
  });

  device.on('error', function(error) {
    console.error('[IoT] Error:', error);
  });

  device.on('close', function() {
    console.log('[IOT] Connection closed');
    event.reply('fromMain', { iotStatus: 'Connection closed' });
  });

  device.on('reconnect', function() {
    console.log('[IOT] Reconnecting...');
    event.reply('fromMain', { iotStatus: 'Reconnecting...' });
  });

  device.on('offline', function() {
    console.log('[IOT] Offline');
    event.reply('fromMain', { iotStatus: 'Offline' });
  });
}



/*
  disconnect IoT - gracefully disconnect from IoT
*/
function disconnectIot(event) {
  if (device) {
    device.end(true, () => {
      console.log('[IOT] Disconnected from AWS IoT');
      if (event) event.reply('fromMain', { iotStatus: 'Offline' });
      device = null;
    });
  } else {
    console.log('[IOT] Already disconnected from IoT');
  }
}



/*
  send IoT message - publish a message to a specified topic on the IoT device.
  modified to use QoS 1.
*/
function sendIotMessage(topic, message) {
  if (device) {
    device.publish(topic, JSON.stringify(message), { qos: 1 }, (err) => {
      if (err) {
        console.error('[IOT] Publish error:', err);
      } else {
        // console.log('[IOT] Message sent to topic:', topic);
      }
    });
  } else {
    console.error('[IOT] IoT device is not connected');
  }
}



/*
  get computer name - read from file
*/
function getComputerName() {
  const filePath = path.join(__dirname, 'computer_name.txt');
  try {
    let data = fs.readFileSync(filePath, 'utf-8').trim();
    
    if (!data) {
      // if file is empty, use desktop name and write it to file
      data = os.hostname();
      fs.writeFileSync(filePath, data, 'utf-8');
      console.log(`File was empty. Using and saving desktop name: ${data}`);
    } else {
      console.log(`Found cached computer name: ${data}`);
    }

    return data;
  } catch (err) {
    // if file doesn't exist, use desktop name and write it to file
    const desktopName = os.hostname();
    fs.writeFileSync(filePath, desktopName, 'utf-8');
    console.log(`File didn't exist. Using and saving desktop name: ${desktopName}`);
    return desktopName;
  }
}
